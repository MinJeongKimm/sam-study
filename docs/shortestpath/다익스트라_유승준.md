## 다익스트라 핵심 개념

**하나의 시작 정점**에서 출발하여 그래프 내의 **다른 모든 정점**까지의 **최단 경로**를 찾는 알고리즘

- **사용 조건**: 간선에 가중치( 비용, 시간 등)가 있어야 하며, **음수 가중치는 없어야 한다.**

- **핵심 원리**: 탐욕적(Greedy) 접근법을 사용한다. 각 단계에서 현재까지 알려진 가장 짧은 경로를 가진 정점을 선택하고, 그 경로를 최종적으로 확정해나간다.


---


### 기본 구현 원리 (배열 사용)

알고리즘의 가장 기본적인 형태로, 동작 원리를 이해하기 쉽다.

1. **초기화**

    - 시작 정점에서 각 정점까지의 거리를 저장할 `distance` 배열을 생성하고, 시작점은 `0`, 나머지는 무한(INF)으로 초기화한다.

    - 정점의 방문(거리 확정) 여부를 기록할 `visited` 배열을 생성한다.

2. **탐색 및 확정**

    - `visited` 하지 않은 정점 중에서, `distance` 값이 가장 작은 정점을 선택한다.

    - 선택한 정점을 `visited` 처리하여 거리를 **확정**한다.

3. **거리 갱신**

    - 방금 확정한 정점을 경유하여 다른 정점들로 가는 경로를 계산한다.

    - 기존 `distance` 값보다 더 짧은 경로가 발견되면, 해당 정점의 `distance` 값을 갱신한다.

4. **반복**

    - 모든 정점을 방문할 때까지 2번과 3번 과정을 반복한다.

- **시간 복잡도**: O(V2) (V: 정점의 개수)

- **병목 지점**: 2번 과정에서 '가장 거리가 짧은 정점'을 찾기 위해 매번 모든 정점을 순차 탐색해야 하므로 비효율적이다.


### 논리적 증명: 왜 Greedy 선택이 가능한가?

다익스트라가 '가장 가까운 정점'의 거리를 바로 확정할 수 있는 이유는 **음수 가중치가 없다는 대전제** 때문이다.

- **논리**: 현재까지의 최단 거리가 `10`인 정점 `A`가 있다고 가정하자. `A`보다 더 멀리 있는 다른 미방문 정점 `B`(거리가 10 이상)를 거쳐 `A`로 돌아오는 경로는 `(B까지의 거리) + (B에서 A까지의 거리)`가 된다. 이때 `(B까지의 거리) >= 10` 이고, 음수 가중치가 없으므로 `(B에서 A까지의 거리) >= 0` 이다. 따라서 이 경로의 총거리는 절대로 `10`보다 짧아질 수 없다.

- **결론**: 이 원리 덕분에 한 번 선택된 최단 거리 정점은 다시 고려할 필요 없이 그 경로가 최단 거리임이 보장된다. 만약 음수 가중치가 있다면 이 가정이 깨지므로 **벨만-포드(Bellman-Ford)** 등의 다른 알고리즘을 사용해야 한다.


---


## 우선순위 큐(Priority Queue)를 이용한 최적화

기본 원리의 병목 지점을 개선한 표준적인 구현 방식이다.

- **개선점**: '가장 거리가 짧은 정점을 찾는' 과정을 **우선순위 큐**를 사용하여 자동화 및 최적화한다.

- **동작 방식**

    1. `distance` 배열을 무한(INF)으로 초기화하고, 시작점만 `0`으로 설정한다.

    2. 우선순위 큐에 `(거리: 0, 정점: 시작점)`을 넣는다.

    3. 큐가 빌 때까지 다음을 반복한다.

        - 큐에서 **거리가 가장 짧은 정점 정보**를 꺼낸다. (이 과정이 O(logV))

        - 꺼낸 정점을 경유하여 인접 정점까지의 거리를 계산하고, 기존 `distance` 값보다 짧으면 갱신한 뒤 **우선순위 큐에 추가**한다.

- **시간 복잡도**: O(ElogV) (E: 간선의 개수, V: 정점의 개수)

    - 대부분의 경우 $O(V^2)$보다 훨씬 효율적이므로 코딩 테스트에서는 이 방식이 표준으로 사용된다.


### 우선순위 큐의 중복과 무시 로직

우선순위 큐를 사용하는 다익스트라 알고리즘에서는 특정 정점까지의 더 짧은 경로를 발견할 때마다 우선순위 큐에 `(갱신된 거리, 정점)` 정보를 새로 추가한다. 이때 기존에 들어있던 `(더 긴 거리, 정점)` 정보를 제거하지 않기 때문에, **하나의 정점에 대한 정보가 우선순위 큐에 중복으로 존재**할 수 있다.

**이 중복된 데이터를 처리하는 방법이 '거리가 같은지를 비교하는 조건문'인 셈이다.**

1. 우선순위 큐는 거리가 가장 짧은 순으로 데이터를 꺼낸다. 따라서 특정 정점 `A`에 대한 정보가 `(거리: 5, 정점: A)`, `(거리: 10, 정점: A)` 두 개 들어있다면, `(5, A)`가 반드시 먼저 나온다.

2. `A`의 `distance` 값은 5로 갱신되고, `A`를 기준으로 인접 노드 탐색이 진행된다.

3. 나중에 `(10, A)`가 큐에서 나올 차례가 되었을 때, 이 값을 꺼내 `distance[A]`와 비교한다.

4. 현재 `distance[A]`는 `5`이고, 큐에서 꺼낸 거리는 `10`이다. `10 > 5` 이므로 이 경로는 이미 이전에 처리된 더 짧은 경로보다 비효율적이라는 의미다. 따라서 **이 데이터는 무시하고 `continue`** 한다.


### **방문 배열(`visited`)이 필요 없는 이유**

이 `if (꺼낸 거리 > distance[정점])` 조건문이 **사실상 `visited` 배열의 역할을 겸하기 때문**이다. 어떤 정점의 최단 거리가 확정되어 처리되고 나면, 그 이후에 우선순위 큐에서 나오는 해당 정점의 정보는 항상 확정된 최단 거리보다 긴 경로일 수밖에 없다. 따라서 이 조건문에 의해 자연스럽게 걸러지므로, 별도의 `visited` 배열이 필요 없게 된다.


---


## 다익스트라 구현 3대 핵심 포인트

1. **최소 힙 (Min-Heap) 사용**

    - 다익스트라는 '가장 거리가 짧은' 노드를 계속해서 뽑아내야 한다. 따라서 우선순위 큐는 **최솟값을 최우선으로 반환하는 최소 힙**으로 구현되어야 한다. 많은 언어의 기본 우선순위 큐가 최대 힙이므로, 최소 힙으로 사용하기 위한 별도 처리가 필요할 수 있다.

2. **{거리, 정점} 순서로 저장**

    - 우선순위 큐는 저장된 데이터의 **첫 번째 원소를 기준**으로 정렬하는 경우가 많다. 우리는 '거리'를 기준으로 가장 짧은 것을 뽑아야 하므로, 튜플이나 페어(pair)를 저장할 때 반드시 **거리를 맨 앞에** 두어야 한다. `{정점, 거리}` 순으로 넣으면 의도와 다르게 정점 번호 순으로 정렬될 수 있다.

3. **"더 긴 경로"는 무시 (Pruning)**

    - 우선순위 큐에는 같은 정점에 대한 정보가 여러 번 들어갈 수 있다. 따라서 큐에서 원소를 꺼냈을 때, **이미 기록된 최단 거리보다 긴 경로라면 볼 필요도 없이 무시**해야 한다. 이 `if (꺼낸 거리 > 최단 거리 테이블 값)` 조건문은 불필요한 탐색을 막는 핵심적인 최적화다.


---


## 다익스트라 경로 복원: pre 테이블 활용법

다익스트라 알고리즘은 시작점에서 각 정점까지의 **최단 거리**를 계산하지만, 어떤 경로를 거쳐가는지에 대한 정보는 기본적으로 저장하지 않는다. `pre` (predecessor, 선행 정점) 테이블은 각 정점까지의 최단 경로가 **어떤 바로 이전 정점으로부터 왔는지를 기록**하여, 이 문제를 해결한다.


### 1. 경로 기록 메커니즘

`distance` 배열의 값이 갱신될 때 함께 기록한다. 즉, `u` 정점을 거쳐 `v` 정점으로 가는 경로가 기존 경로보다 짧아 `distance[v]` 값을 갱신할 때, `pre[v]`에 `u`를 저장한다.


#### 의사 코드 (Pseudocode)

```
// u를 거쳐 v로 가는 경로가 더 짧은 경우
if (distance[u] + weight(u, v) < distance[v]) {
    // 거리를 갱신한다.
    distance[v] = distance[u] + weight(u, v);

    // v의 최단 경로상 바로 이전 정점은 u임을 기록한다.
    pre[v] = u;
}
```


### 2. 경로 역추적 방법

다익스트라 알고리즘이 종료된 후, `pre` 테이블을 이용해 **도착점에서부터 시작점까지 경로를 거슬러 올라간다.**

1. **시작**: 도착 정점 `dest`에서 추적을 시작한다. 경로를 저장할 리스트(또는 스택)에 `dest`를 추가한다.

2. **반복**: 현재 정점이 시작 정점 `start`가 될 때까지 다음을 반복한다.

    - `pre[현재 정점]`을 다음 추적 대상으로 삼는다.

    - 새로운 대상을 경로 리스트에 추가한다.

3. **결과**: 추적이 끝나면 경로는 `[도착점, ..., 중간점, ..., 시작점]` 순서로 저장된다. 사용자가 일반적으로 인지하는 순서로 보여주려면, 이 리스트를 뒤집어 주어야 한다.


#### 의사 코드 (Pseudocode)

```
function reconstruct_path(start, dest, pre_table):
    path = []
    current_node = dest

    while (current_node is not undefined):
        path.append(current_node)
        current_node = pre_table[current_node]

    // 경로를 [시작점, ..., 도착점] 순서로 뒤집는다.
    return reverse(path)
```