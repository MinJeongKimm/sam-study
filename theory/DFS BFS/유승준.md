
### **BFS (너비 우선 탐색)**

- **BFS**는 그래프의 모든 정점을 탐색하는 대표적인 알고리즘 중 하나.

- 이름 그대로 **'너비를 우선으로'** 하여, 시작 정점에서 가까운 정점들을 먼저 방문하고 멀리 있는 정점들을 나중에 방문하는 방식임.

> 호수에 돌을 던졌을 때 물결이 동심원을 그리며 퍼져나가는 모습을 상상하면 이해하기 쉬움. 시작점이라는 첫 물결에서 시작해, 다음으로 가까운 정점들의 두 번째 물결, 그다음 정점들의 세 번째 물결 순으로 탐색을 진행함.

#### **BFS의 특징 및 활용**

- **최단 경로 보장**: 각 간선의 가중치가 동일할 때, 시작점에서 특정 정점까지의 **최단 경로**를 항상 찾아줌.

- **큐(Queue) 사용**: '먼저 온 것을 먼저 처리하는' 선입선출(FIFO) 방식의 큐(Queue) 자료구조를 사용하여 탐색 순서를 관리함.


#### **BFS를 구현하려면**

- 선입선출 구조를 따르는 Queue 인터페이스를 사용
- Queue 구현체로서, 대표적인 클래스로는 ArrayDeque과 LinkedList 존재


#### **BFS 구현 시 대표적인 Pitfall 3가지**

- **시작 노드 방문 처리 누락**

    - 가장 처음 큐에 넣는 시작 노드에 대해 방문(`visited`) 표시를 누락하는 경우.

    - 그래프 구조에 따라 시작 노드가 큐에 중복으로 추가될 수 있어 불필요한 탐색을 유발함.

    ```Java
    // Bad
    queue.add(startNode);
    // visited[startNode] = true;  <- 이 라인을 누락할 수 있음
    
    // Good
    queue.add(startNode);
    visited[startNode] = true;     // 큐에 넣는 즉시 방문 처리
    ```

- **방문 처리의 "잘못된 타이밍"**

    - 큐에 요소를 넣을 때(`add`)가 아닌, 큐에서 뺄 때(`poll`) 방문 처리하는 경우. 이는 **메모리 초과나 시간 초과의 주범**이 됨.

    - 동일한 노드가 큐에 여러 번 중복으로 쌓일 수 있기 때문. **이 노드는 곧 탐색할 예정**이라는 예약 효과를 위해, 노드는 **큐에 넣기 직전에 방문 처리**하는 것이 정석임.

    ```Java
    // Bad - 큐에서 뺄 때 방문 처리
    int curr = queue.poll();
    if(visited[curr]) continue; // 이미 방문한 노드는 무시
    visited[curr] = true;       // 여기서 처리하면 너무 늦음
    
    for (int next : graph[curr]) {
        // next 노드가 이미 큐에 들어있어도, visited가 false라 또 추가될 수 있음
        if (!visited[next]) {
            queue.add(next);
        }
    }
    
    // Good - 큐에 넣기 직전 방문 처리
    int curr = queue.poll();
    
    for (int next : graph[curr]) {
        // 큐에 넣기 전에 미리 검사하고, 방문 처리까지 완료
        if (!visited[next]) {
            visited[next] = true; // 방문 예약
            queue.add(next);
        }
    }
    ```

- **경계(Boundary) 검사 누락**

    - 주로 2차원 배열(격자, 미로) 문제를 풀 때 발생하는 실수.

    - 다음 위치가 배열의 범위를 벗어나는지 확인하지 않을 경우, `ArrayIndexOutOfBoundsException` 에러가 발생하며 프로그램이 즉시 종료됨.

    ```Java
    // nextX, nextY는 다음 탐색 좌표
    // N, M은 배열의 행, 열 최대 크기
    
    // Bad
    // 경계 검사 없이 배열에 접근하면 위험
    if (!visited[nextX][nextY]) {
        queue.add(new int[]{nextX, nextY});
        visited[nextX][nextY] = true;
    }
    
    // Good
    // 다음 행동을 하기 전에, 경계 검사를 가장 먼저 수행해야 함
    if (nextX >= 0 && nextY >= 0 && nextX < N && nextY < M) {
        if (!visited[nextX][nextY]) {
            queue.add(new int[]{nextX, nextY});
            visited[nextX][nextY] = true;
        }
    }
    ```


#### **큐 구현 시, 어떤 클래스를 사용할까?**

ArrayDeque은 내부적으로 배열을 사용함. **데이터가 메모리상에서 연속적으로 배치되어 있어 CPU 캐시가 매우 효율적으로 동작함 (캐시 히트율이 높음).** 이러한 메모리 지역성 덕분에 요소의 추가 및 제거 속도가 훨씬 빠른 편임.

LinkedList는 각 노드가 메모리 곳곳에 흩어져 있음. 다음 노드를 찾기 위해 포인터를 따라 메모리의 다른 위치로 계속 이동해야 함. 캐시 효율이 떨어져 ArrayDeque보다 느림.


#### **ArrayDeque은 무조건 좋을까?**

**배열 기반**이라 함은, **오토 리사이징**을 한다는 뜻. 풀어서 설명하자면, 필요에 따라 동적으로 배열의 크기를 늘림과 동시에 이전 배열은 복사해버림. 이 과정에서 **힙 단편화**가 문제될 수 있음.

> ArrayDeque이 가득 차면, 더 큰 '연속된 메모리 공간'을 새로 할당하여 기존 데이터를 복사함. 만약 힙 메모리가 조각나 있다면, 전체 여유 공간이 충분하더라도 연속된 공간을 찾지 못해 OutOfMemoryError가 발생할 수 있음 (BOJ 13909번 문제 참고).

자바의 GC로 인해 빈 공간이 생기는 것도 맞지만, GC의 압축으로 인해 연속된 메모리 공간을 확보하기도 함. 실제 애플리케이션 환경에서 자주 접할 수 있는 문제는 아님.

결론적으로 BFS의 핵심 연산을 중점으로 판단할 때, null 값을 큐에 넣어야 하는 극히 드문 경우나 극심한 메모리 단편화가 예상되는 특수한 환경이 아니라면 ArrayDeque이 LinkedList보다 밀릴 이유는 없음.


### **오토 리사이징**

ArrayDeque은 내부 배열이 꽉 찰 때마다 용량을 정확히 두 배로 늘리는 '더블링' 전략을 사용함.

1. 최초 생성 시 내부적으로 16의 초기 용량을 가진 배열이 만들어짐.
2. 16개의 요소가 모두 차고, 17번째 요소를 추가하려고 하는 시점에 리사이징 발생.
3. doubleCapacity()라는 내부 메서드 호출 (기존 용량의 두 배인 32 크기의 배열 생성).
4. 기존 배열의 모든 요소를 새 배열로 복사

#### 왜 2배씩 늘릴까?

- 단순히 10개씩, 또는 100개씩 고정된 크기로 느리지 않고 2배씩 늘리는 이유는 **분할 상환 분석** 관점에서 삽입 비용을 평균 O(1)으로 만들기 위함임.

- 리사이징은 Logarithmic하게 발생하지만, 한 번 할 때마다 비용이 큰 편임. 이러한 비싼 비용이 수많은 '비용이 싼' 일반 삽입 연산들 사이 분산될 경우, 결과적으로 n개의 요소를 추가할 때 전체 비용을 n으로 나누면 삽입 한 번당 평균 비용이 상수 시간, 즉 O(1)에 수렴하게 됨.

> 메모리 공간을 조금 더 사용하는 대신, 장기적으로 훨씬 뛰어난 삽입 성능을 보장하는 매우 효과적인 트레이드 오프인 셈. 현대에는 메모리 공간이 과거 대비 널널한 편인 것도 이유가 될 수 있음.

---

### **DFS (깊이 우선 탐색)**

**DFS**는 이름처럼 **'깊이를 우선으로'** 하여, 한 번 파고든 경로를 막다른 길에 다다를 때까지 탐색한 후, 이전 갈림길로 돌아와 다른 경로를 탐색하는 방식임.

> 미로를 탐색할 때, 한 쪽 벽을 계속 따라가다가 막히면 뒤로 돌아와 다른 길로 들어서는 전략을 생각하면 됨. 깊이를 우선으로 하기 때문에 일단 끝까지 탐색함.


#### **DFS의 특징 및 구현**

- **모든 경로 탐색**: DFS는 특정 경로의 끝까지 탐색하기 때문에, 모든 가능한 경로를 찾아야 하는 문제에 적합함. (예: 모든 조합/순열 찾기, 경로 존재 여부 확인)

- **스택(Stack) 또는 재귀(Recursion) 사용**: '가장 나중에 온 것을 먼저 처리하는' 후입선출(LIFO) 방식으로 동작함. 이는 **스택(Stack)** 자료구조의 동작 방식과 일치하며, 함수의 호출 스택을 이용하는 **재귀 함수**로 구현하면 매우 간결하고 직관적임.

- **메모리 효율성**: 현재 탐색 중인 경로의 정보만 저장하므로, BFS에 비해 일반적으로 메모리를 적게 사용하나 크게 중요한 부분은 아님.


#### **구현 방법: 재귀 vs. 스택**

> DFS는 재귀를 이용하는 것이 가장 일반적이고, 스택을 이용하면 반복문으로 구현할 수 있음.

##### **1. 재귀 (Recursion)를 이용한 구현 (가장 직관적)**

함수 호출 스택이 DFS의 스택 역할을 암묵적으로 수행하여 코드가 매우 간결해짐.

```Java
boolean[] visited; // 방문 여부 체크 배열

void dfs(int currentNode) {
    // 1. 방문 처리
    visited[currentNode] = true;
    System.out.println(currentNode + " 방문"); // 로직 수행

    // 2. 인접 노드 탐색
    for (int nextNode : graph[currentNode]) {
        // 3. 방문하지 않은 노드로 재귀 호출
        if (!visited[nextNode]) {
            dfs(nextNode); // 더 깊이 들어감
        }
    }
}
```

#### **2. 스택 (Stack)을 이용한 구현**

> 재귀의 `StackOverflowError`를 피하고 싶거나, 탐색 과정을 더 명시적으로 제어하고 싶을 때 사용함.

```Java
void dfs(int startNode) {
    Stack<Integer> stack = new Stack<>();
    boolean[] visited = new boolean[노드개수];

    // 1. 시작 노드를 스택에 추가
    stack.push(startNode);

    // 2. 스택이 빌 때까지 반복
    while (!stack.isEmpty()) {
        int currentNode = stack.pop();

        if (visited[currentNode]) continue; // 이미 방문했다면 건너뜀
        visited[currentNode] = true;        // 방문 처리
        System.out.println(currentNode + " 방문"); // 로직 수행

        // 3. 인접 노드를 스택에 추가
        // ※ 재귀와 순서를 맞추려면 인접 노드를 역순으로 넣어야 함
        for (int i = graph[currentNode].size() - 1; i >= 0; i--) {
            int nextNode = graph[currentNode].get(i);
            if (!visited[nextNode]) {
                stack.push(nextNode);
            }
        }
    }
}
```


#### **DFS 구현 시 대표적인 Pitfall 3가지**

- **재귀의 종료 조건 부재 (Base Case)**

    - **문제점**: 재귀 함수가 언제 멈춰야 할지 명시하지 않으면, 끝없이 자기 자신을 호출하다가 `StackOverflowError`가 발생.

    - **해결책**: 모든 노드를 방문했거나, 문제에서 원하는 특정 조건에 도달했을 때 재귀를 멈추는 **종료 조건**을 반드시 명시해야 함.

- **잘못된 방문 처리와 복구 (백트래킹)**

    - **문제점**: 단순히 모든 노드를 한 번씩만 방문하는 것이 아니라, 특정 경로를 탐색 후 되돌아와 다른 경로를 탐색해야 하는 경우(예: 모든 조합 찾기), 방문 표시(`visited`)를 제대로 해제하지 않으면 다른 경로를 탐색할 기회를 차단하게 됨.

    - **해결책**: 한 경로의 탐색이 끝나고 함수가 반환되기 직전에, `visited` 상태를 다시 `false`로 되돌려 놓아 다른 경로에서 해당 노드를 다시 방문할 수 있도록 해야 함. 이를 **백트래킹**이라고 하며, SWEA에서 '보호 필름' 문제를 풀어보는 것을 추천함.

    ```Java
    // 백트래킹 예시
    void findCombinations(int at, int depth) {
        if (depth == R) { /* 조합 완성 */ return; }
    
        for (int i = at; i < N; i++) {
            visited[i] = true;          // 1. 상태 변경 (방문)
            findCombinations(i + 1, depth + 1); // 2. 재귀 호출
            visited[i] = false;         // 3. 상태 복구 (매우 중요!)
        }
    }
    ```